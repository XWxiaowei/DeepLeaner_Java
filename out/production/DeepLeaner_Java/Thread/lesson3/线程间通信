把一个数据存储空间划分成两个部分，一部分用于存储人的，另一个部分用于存储人的性别，
这里的引用包含两个线程，一个线程向数据存储空间添加数据（生成者）
一个线程用于从数据空间取出数据（消费者），这个程序有两个意外需要考虑：
1.假设生产者线程刚向数据存储空间加入了一个人的姓名，还没有加入这个人的性别
，cpu就切换到了消费者线程，消费者线程则把这个人的姓名和上一个人的性别联系到了一起。
2.第二种意外：生成者放入了若干的数据，消费者才开始取出数据，或者是，消费者取完一个
数据后，还没等到生产者加入新的数据，又重复取出已经取过的数据。

另外 还需要保证 producer放入一次数据，那么consumer就读取一次数据
反之，producer也必须等到consumer读取完数据之后才能够放入新的数据
而这一问题的解决，就需要使用继承自Object类的wait、notify、notifyAll这几个方法
来实现线程间的通信，又因为所有的类都是自Object继承而来的，所以任何类都是自
Object继承而来。
  wait:告诉当前的线程放弃监视器并且进入睡眠状态，直到其他线程进入同一个
  监视器并调用notify方法为止，
  notify:唤醒同一个监视器中调用wait的第一个线程，这类似排队买票，这类似于排队买票，
  一个人买完后面的人才可以买
  notifyAll:唤醒同一个对象监视器里面调用的wait的所有线程,具有最高优先级的线程
  首先被唤醒和执行。

另外 ，需要注意的是wait,notify,notifyAll这三个方法只能在synchronized方法里面调用
，也就是无论线程调用一个对象的wait还是notify方法，该线程必须先得到对象的锁标记。
这样，notify就只能唤醒同一对象监视器中调用wait的线程，而使多的个对象监视器，
就可以分别有多个wait、notify的情况，同组里的wait也只能被同组的notify唤醒。

    一个线程的等待和唤醒流程如下：
                           Thread t

，                        synchronized(this)<----线程t得到对象的锁标记

                            wait()<----------此时线程t被放置在对象的等待线程池中，t自动释放对象的锁标记

                            notify<-------- 当另外的线程执行了对象的notify方法后，
                            线程t就可能会被从对象的等待线程池里面释放出来，并且移动到
                            等待线程对象的锁标记的线程池里面，当t得到锁的标记就会执行下去。